import fs from "fs/promises";
import path from "path";
import { exec } from "child_process";
import { promisify } from "util";

const execAsync = promisify(exec);

export interface ProjectInitResult {
  success: boolean;
  message?: string;
  projectPath?: string;
  error?: string;
}

export async function initializeReactProject(): Promise<ProjectInitResult> {
  try {
    const projectName = "my-react-app";
    const projectPath = path.join(process.cwd(), "generated-projects", projectName);
    
    // Create the projects directory if it doesn't exist
    const projectsDir = path.join(process.cwd(), "generated-projects");
    await fs.mkdir(projectsDir, { recursive: true });
    
    // Check if project already exists
    try {
      await fs.access(projectPath);
      return {
        success: false,
        error: `Project '${projectName}' already exists. Please remove it first or choose a different name.`,
      };
    } catch {
      // Project doesn't exist, which is what we want
    }
    
    console.log(`Initializing React project at: ${projectPath}`);
    
    // Create React app using npx create-react-app
    const { stdout, stderr } = await execAsync(
      `npx create-react-app ${projectName} --template typescript`,
      { 
        cwd: projectsDir,
        timeout: 300000 // 5 minutes timeout
      }
    );
    
    console.log("React app creation stdout:", stdout);
    if (stderr) {
      console.log("React app creation stderr:", stderr);
    }
    
    // Verify the project was created successfully
    try {
      await fs.access(path.join(projectPath, "package.json"));
    } catch {
      throw new Error("Failed to create React project - package.json not found");
    }
    
    // Create a basic README for the generated project
    const readmeContent = `# Generated React Project

This React project was generated by DataFlow Designer.

## Getting Started

1. Navigate to the project directory:
   \`\`\`bash
   cd generated-projects/${projectName}
   \`\`\`

2. Install dependencies:
   \`\`\`bash
   npm install
   \`\`\`

3. Start the development server:
   \`\`\`bash
   npm start
   \`\`\`

## Project Structure

- \`src/\` - Source code directory
- \`public/\` - Public assets
- \`package.json\` - Project dependencies and scripts

## Available Scripts

- \`npm start\` - Runs the app in development mode
- \`npm test\` - Launches the test runner
- \`npm run build\` - Builds the app for production
- \`npm run eject\` - Ejects from Create React App (one-way operation)

Generated on: ${new Date().toISOString()}
`;
    
    await fs.writeFile(path.join(projectPath, "README.md"), readmeContent);
    
    return {
      success: true,
      message: `React project '${projectName}' created successfully at ${projectPath}`,
      projectPath,
    };
    
  } catch (error) {
    console.error("Error initializing React project:", error);
    
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error occurred while initializing project",
    };
  }
}

export async function createCustomReactProject(projectName: string): Promise<ProjectInitResult> {
  try {
    // Clean project name (remove special characters)
    const cleanProjectName = projectName.replace(/[^a-zA-Z0-9-_]/g, '-').toLowerCase();
    const projectPath = path.join(process.cwd(), "generated-projects", cleanProjectName);
    
    // Create the projects directory if it doesn't exist
    const projectsDir = path.join(process.cwd(), "generated-projects");
    await fs.mkdir(projectsDir, { recursive: true });
    
    // Check if project already exists
    try {
      await fs.access(projectPath);
      return {
        success: false,
        error: `Project '${cleanProjectName}' already exists. Please choose a different name.`,
      };
    } catch {
      // Project doesn't exist, which is what we want
    }
    
    console.log(`Creating custom React project at: ${projectPath}`);
    
    // Create React app using npx create-react-app
    const { stdout, stderr } = await execAsync(
      `npx create-react-app ${cleanProjectName} --template typescript`,
      { 
        cwd: projectsDir,
        timeout: 300000 // 5 minutes timeout
      }
    );
    
    console.log("React app creation stdout:", stdout);
    if (stderr) {
      console.log("React app creation stderr:", stderr);
    }
    
    return {
      success: true,
      message: `React project '${cleanProjectName}' created successfully`,
      projectPath,
    };
    
  } catch (error) {
    console.error("Error creating custom React project:", error);
    
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error occurred while creating project",
    };
  }
}

export async function getProjectsList(): Promise<any[]> {
  try {
    const projectsDir = path.join(process.cwd(), "generated-projects");
    
    // Check if projects directory exists
    try {
      await fs.access(projectsDir);
    } catch {
      // Directory doesn't exist, return empty array
      return [];
    }
    
    const entries = await fs.readdir(projectsDir, { withFileTypes: true });
    const projects = [];
    
    for (const entry of entries) {
      if (entry.isDirectory()) {
        const projectPath = path.join(projectsDir, entry.name);
        const packageJsonPath = path.join(projectPath, "package.json");
        
        try {
          // Check if it's a valid React project
          await fs.access(packageJsonPath);
          const stat = await fs.stat(projectPath);
          
          // Read package.json to get project type
          const packageContent = await fs.readFile(packageJsonPath, "utf-8");
          const packageJson = JSON.parse(packageContent);
          
          projects.push({
            name: entry.name,
            path: projectPath,
            type: packageJson.dependencies?.react ? "React Project" : "Node Project",
            lastModified: stat.mtime.toISOString(),
          });
        } catch {
          // Skip invalid projects
          continue;
        }
      }
    }
    
    return projects;
  } catch (error) {
    console.error("Error listing projects:", error);
    return [];
  }
}

export async function getProjectFiles(projectName: string): Promise<any[]> {
  try {
    const projectPath = path.join(process.cwd(), "generated-projects", projectName);
    
    // Verify project exists
    await fs.access(projectPath);
    
    const files = await scanDirectory(projectPath, projectPath);
    return files;
  } catch (error) {
    console.error("Error reading project files:", error);
    throw new Error(`Failed to read files for project: ${projectName}`);
  }
}

async function scanDirectory(dirPath: string, basePath: string, maxDepth = 3, currentDepth = 0): Promise<any[]> {
  if (currentDepth >= maxDepth) {
    return [];
  }
  
  try {
    const entries = await fs.readdir(dirPath, { withFileTypes: true });
    const items = [];
    
    for (const entry of entries) {
      // Skip node_modules, .git, and other common directories
      if (entry.name.startsWith('.') || entry.name === 'node_modules' || entry.name === 'build' || entry.name === 'dist') {
        continue;
      }
      
      const fullPath = path.join(dirPath, entry.name);
      const relativePath = path.relative(basePath, fullPath);
      
      if (entry.isDirectory()) {
        const children = await scanDirectory(fullPath, basePath, maxDepth, currentDepth + 1);
        items.push({
          name: entry.name,
          type: 'directory',
          path: relativePath,
          children,
          expanded: currentDepth === 0, // Auto-expand only root level
        });
      } else {
        items.push({
          name: entry.name,
          type: 'file',
          path: relativePath,
        });
      }
    }
    
    return items;
  } catch (error) {
    console.error(`Error scanning directory ${dirPath}:`, error);
    return [];
  }
}

export async function deleteProject(projectName: string): Promise<void> {
  try {
    const projectPath = path.join(process.cwd(), "generated-projects", projectName);
    
    // Verify project exists
    await fs.access(projectPath);
    
    // Delete the entire project directory
    await fs.rm(projectPath, { recursive: true, force: true });
    
    console.log(`Project deleted: ${projectPath}`);
  } catch (error) {
    console.error("Error deleting project:", error);
    throw new Error(`Failed to delete project: ${projectName}`);
  }
}

export async function renameProject(oldName: string, newName: string): Promise<void> {
  try {
    // Clean the new project name (remove special characters)
    const cleanNewName = newName.replace(/[^a-zA-Z0-9-_]/g, '-').toLowerCase();
    
    const oldProjectPath = path.join(process.cwd(), "generated-projects", oldName);
    const newProjectPath = path.join(process.cwd(), "generated-projects", cleanNewName);
    
    // Verify old project exists
    await fs.access(oldProjectPath);
    
    // Check if new name already exists
    try {
      await fs.access(newProjectPath);
      throw new Error(`A project with name '${cleanNewName}' already exists`);
    } catch (error) {
      // If it throws an error, the project doesn't exist, which is what we want
      if (error instanceof Error && error.message.includes('already exists')) {
        throw error; // Re-throw if it's our custom error
      }
      // Otherwise, continue with rename
    }
    
    // Rename the project directory
    await fs.rename(oldProjectPath, newProjectPath);
    
    // Update package.json name field
    const packageJsonPath = path.join(newProjectPath, "package.json");
    try {
      const packageContent = await fs.readFile(packageJsonPath, "utf-8");
      const packageJson = JSON.parse(packageContent);
      packageJson.name = cleanNewName;
      await fs.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2));
    } catch (error) {
      console.warn("Could not update package.json name field:", error);
      // Don't fail the rename if we can't update package.json
    }
    
    console.log(`Project renamed from '${oldName}' to '${cleanNewName}'`);
  } catch (error) {
    console.error("Error renaming project:", error);
    throw new Error(`Failed to rename project: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}